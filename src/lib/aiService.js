import { supabaseAPI } from './supabase';
import { supabaseCuisine } from './supabase-cuisine';
import { openaiAPI } from './openai';

// Journal des modifications IA pour tra√ßabilit√©
let aiModificationLog = [];

// ========================= GESTION DU CONTEXTE CONVERSATIONNEL =========================
let conversationContext = {
  lastMentionedEmployee: null,
  lastMentionedVehicle: null,
  lastAction: null,
  lastTopics: [], // Derniers sujets abord√©s
  timestamp: null
};

// Fonction pour extraire et sauvegarder le contexte d'un message
const updateConversationContext = (userMessage, aiResponse) => {
  const message = userMessage.toLowerCase();
  
  // D√©tecter les noms d'employ√©s mentionn√©s
  const employeeNames = ['shadi', 'tamara', 'ahmad', 'martial', 'margot', 'soroosh', 'imad', 'basel', 'tesfa', 'firas', 'juan', 'jos√©', 'emaha', 'medha', 'deazevedo'];
  const mentionedEmployee = employeeNames.find(name => message.includes(name));
  
  if (mentionedEmployee) {
    conversationContext.lastMentionedEmployee = mentionedEmployee.charAt(0).toUpperCase() + mentionedEmployee.slice(1);
    conversationContext.timestamp = Date.now();
  }
  
  // D√©tecter les v√©hicules mentionn√©s
  const vehicleNames = ['crafter', 'jumper', 'ducato', 'transit'];
  const mentionedVehicle = vehicleNames.find(name => message.includes(name));
  
  if (mentionedVehicle) {
    conversationContext.lastMentionedVehicle = mentionedVehicle;
    conversationContext.timestamp = Date.now();
  }
  
  // D√©tecter les actions et le contexte de conversation
  if (message.includes('absent') || message.includes('disponible')) {
    conversationContext.lastAction = 'availability_check';
  } else if (message.includes('planning') || message.includes('√©quipe') || message.includes('√©quipe')) {
    conversationContext.lastAction = 'team_planning';
  } else if (message.includes('mettre') && (message.includes('avec') || message.includes('dans'))) {
    conversationContext.lastAction = 'team_assignment';
  }
  
  // D√©tecter si l'IA vient de faire des suggestions d'√©quipes
  if (aiResponse.includes('proposer') || aiResponse.includes('associer') || aiResponse.includes('r√®gles d\'insertion')) {
    conversationContext.lastAction = 'awaiting_team_confirmation';
  }
  
  // Nettoyer le contexte apr√®s 5 minutes
  if (conversationContext.timestamp && Date.now() - conversationContext.timestamp > 300000) {
    conversationContext = {
      lastMentionedEmployee: null,
      lastMentionedVehicle: null,
      lastAction: null,
      lastTopics: [],
      timestamp: null
    };
  }
};

// Fonction pour r√©soudre les r√©f√©rences dans un message
const resolveReferences = (message) => {
  let resolvedMessage = message;
  
  // R√©soudre les pronoms si on a un contexte
  if (conversationContext.lastMentionedEmployee && conversationContext.timestamp && 
      Date.now() - conversationContext.timestamp < 120000) { // 2 minutes
    
    // Remplacer les r√©f√©rences par le nom de l'employ√©
    resolvedMessage = resolvedMessage
      .replace(/\b(il|lui)\b/gi, conversationContext.lastMentionedEmployee)
      .replace(/\b(elle|la)\b/gi, conversationContext.lastMentionedEmployee)
      .replace(/\b(cette personne|cet employ√©|cette employ√©e)\b/gi, conversationContext.lastMentionedEmployee);
  }
  
  return resolvedMessage;
};

// Fonction pour d√©tecter si l'utilisateur donne une instruction directive (d√©j√† confirm√©e)
const isDirectiveInstruction = (message) => {
  const lowerMessage = message.toLowerCase();
  
  // Patterns d'instructions directives qui impliquent d√©j√† une confirmation
  const directivePatterns = [
    /^(oui|ok|d'accord),?\s+(tu peux|vous pouvez|fais|faites|mets|mettez)/,
    /^(oui|ok|d'accord),?\s+(je veux|on peut|il faut)/,
    /^(vas-y|va-y|allez-y|allez y|go)/,
    /^(tu peux|vous pouvez)\s+(mettre|associer|placer|cr√©er|g√©n√©rer)/,
    /^(fais|faites)\s+(le|la|les|√ßa|cela)/,
    /^(mets|mettez)\s+(.+)\s+(avec|dans|sur)/,
    /^(cr√©er?|g√©n√®re|place|associe)\s+/,
    /^(parfait|excellent|tr√®s bien),?\s+(fais|faites|mets|mettez)/
  ];
  
  return directivePatterns.some(pattern => pattern.test(lowerMessage));
};

// Fonction pour extraire l'action demand√©e dans une instruction directive
const extractDirectiveAction = (message) => {
  const lowerMessage = message.toLowerCase();
  
  // D√©tecter la g√©n√©ration de planning avec √©quipes sp√©cifiques
  if (lowerMessage.includes('mettre') || lowerMessage.includes('associer') || lowerMessage.includes('placer')) {
    const teamMatch = message.match(/(?:mettre|associer|placer)\s+(.+?)\s+(?:avec|dans|sur)\s+(.+)/i);
    if (teamMatch) {
      return {
        type: 'CREATE_TEAM_PLANNING',
        employee1: teamMatch[1].trim(),
        employee2: teamMatch[2].trim()
      };
    }
  }
  
  // D√©tecter g√©n√©ration de planning g√©n√©ral
  if (lowerMessage.includes('g√©n√©rer') || lowerMessage.includes('planning') || lowerMessage.includes('cr√©er le planning')) {
    return {
      type: 'GENERATE_PLANNING',
      date: 'demain' // par d√©faut
    };
  }
  
  return null;
};

export const aiService = {
  // ========================= NAVIGATION AUTOMATIQUE =========================
  
  async navigateToPage(pageName, additionalInfo = '') {
    const routes = {
      'accueil': '/',
      'logistique': '/logistique',
      'employes': '/employees',
      'employ√©s': '/employees',
      'planning': '/planning',
      'absences': '/absences',
      'cuisine': '/cuisine',
      'absences cuisine': '/cuisine/absences'
    };

    const route = routes[pageName.toLowerCase()];
    if (route) {
      // Simuler navigation (dans une vraie app, on utiliserait navigate)
      window.history.pushState({}, '', route);
      window.dispatchEvent(new PopStateEvent('popstate'));
      
      this.logModification('NAVIGATION', `Navigation vers ${pageName}`, { page: pageName, route });
      return `üìç Navigation vers **${pageName}** ${additionalInfo}`;
    }
    return `‚ùå Page "${pageName}" non trouv√©e. Pages disponibles: ${Object.keys(routes).join(', ')}`;
  },

  // ========================= JOURNAL DE TRA√áABILIT√â =========================
  
  logModification(action, description, data = {}) {
    const logEntry = {
      id: Date.now(),
      timestamp: new Date().toISOString(),
      action,
      description,
      data,
      user: 'IA_ASSISTANT'
    };
    
    aiModificationLog.push(logEntry);
    
    // Garder seulement les 100 derni√®res modifications
    if (aiModificationLog.length > 100) {
      aiModificationLog = aiModificationLog.slice(-100);
    }
    
    console.log('üìù [IA LOG]', logEntry);
  },

  getModificationLog(limit = 10) {
    return aiModificationLog
      .slice(-limit)
      .reverse()
      .map(entry => `üïê **${new Date(entry.timestamp).toLocaleString('fr-FR')}**\n**${entry.action}:** ${entry.description}`)
      .join('\n\n');
  },

  // ========================= GESTION COMPL√àTE EMPLOY√âS =========================
  
  async createEmployee(employeeData, needsConfirmation = true) {
    try {
      if (needsConfirmation) {
        const confirmationData = {
          action: 'CREATE_EMPLOYEE',
          data: employeeData,
          message: `Cr√©er nouvel employ√©: ${employeeData.nom} ${employeeData.prenom || ''} (${employeeData.profil})`
        };
        return await this.requestConfirmation(confirmationData);
      }

      const result = await supabaseAPI.createEmployee(employeeData);
      if (result.error) throw result.error;

      this.logModification('CREATE_EMPLOYEE', `Employ√© cr√©√©: ${employeeData.nom}`, employeeData);
      return `‚úÖ **Employ√© cr√©√© avec succ√®s !**\nüë§ ${employeeData.nom} ${employeeData.prenom || ''}\nüìä Profil: ${employeeData.profil}\nüó£Ô∏è Langues: ${employeeData.langues?.join(', ') || 'Aucune'}`;

    } catch (error) {
      this.logModification('ERROR', `√âchec cr√©ation employ√©: ${error.message}`, { employeeData, error: error.message });
      return `‚ùå Erreur cr√©ation employ√©: ${error.message}`;
    }
  },

  async updateEmployee(employeeId, updates, needsConfirmation = true) {
    try {
      if (needsConfirmation) {
        const { data: employee } = await supabaseAPI.getEmployee(employeeId);
        const confirmationData = {
          action: 'UPDATE_EMPLOYEE',
          data: { employeeId, updates, currentEmployee: employee },
          message: `Modifier ${employee?.nom}: ${Object.keys(updates).join(', ')}`
        };
        return await this.requestConfirmation(confirmationData);
      }

      const result = await supabaseAPI.updateEmployee(employeeId, updates);
      if (result.error) throw result.error;

      this.logModification('UPDATE_EMPLOYEE', `Employ√© modifi√© (ID: ${employeeId})`, updates);
      return `‚úÖ **Employ√© mis √† jour !**\nüìù Modifications: ${Object.keys(updates).map(key => `${key}: ${updates[key]}`).join(', ')}`;

    } catch (error) {
      this.logModification('ERROR', `√âchec modification employ√©: ${error.message}`, { employeeId, updates });
      return `‚ùå Erreur modification employ√©: ${error.message}`;
    }
  },

  async deleteEmployee(employeeId, needsConfirmation = true) {
    try {
      const { data: employee } = await supabaseAPI.getEmployee(employeeId);
      
      if (needsConfirmation) {
        const confirmationData = {
          action: 'DELETE_EMPLOYEE',
          data: { employeeId, employee },
          message: `‚ö†Ô∏è SUPPRIMER d√©finitivement l'employ√© ${employee?.nom} ? Cette action est irr√©versible !`
        };
        return await this.requestConfirmation(confirmationData);
      }

      const result = await supabaseAPI.deleteEmployee(employeeId);
      if (result.error) throw result.error;

      this.logModification('DELETE_EMPLOYEE', `Employ√© supprim√©: ${employee?.nom}`, { employeeId, deletedEmployee: employee });
      return `üóëÔ∏è **Employ√© supprim√© d√©finitivement**\nüë§ ${employee?.nom} a √©t√© retir√© du syst√®me`;

    } catch (error) {
      this.logModification('ERROR', `√âchec suppression employ√©: ${error.message}`, { employeeId });
      return `‚ùå Erreur suppression employ√©: ${error.message}`;
    }
  },

  // ========================= GESTION COMP√âTENCES AVANC√âE =========================
  
  async validateCompetence(employeeId, vehicleId, niveau = 'X', needsConfirmation = false) {
    try {
      const { data: employee } = await supabaseAPI.getEmployee(employeeId);
      const { data: vehicle } = await supabaseAPI.getVehicle(vehicleId);
      
      if (needsConfirmation) {
        const confirmationData = {
          action: 'VALIDATE_COMPETENCE',
          data: { employeeId, vehicleId, niveau, employee, vehicle },
          message: `Valider comp√©tence ${niveau} pour ${employee?.nom} sur ${vehicle?.nom}`
        };
        return await this.requestConfirmation(confirmationData);
      }

      const competenceData = {
        niveau: niveau,
        date_validation: new Date().toISOString().split('T')[0],
        formateur_id: 1 // IA comme formateur
      };

      const result = await supabaseAPI.updateCompetence(employeeId, vehicleId, competenceData);
      if (result.error) throw result.error;

      this.logModification('VALIDATE_COMPETENCE', `Comp√©tence valid√©e: ${employee?.nom} - ${vehicle?.nom} (${niveau})`, competenceData);
      return `üéØ **Comp√©tence valid√©e !**\nüë§ ${employee?.nom}\nüöõ ${vehicle?.nom}\n‚≠ê Niveau: ${niveau === 'XX' ? '2 √©toiles (autonome)' : '1 √©toile (accompagn√©)'}`;

    } catch (error) {
      this.logModification('ERROR', `√âchec validation comp√©tence: ${error.message}`, { employeeId, vehicleId, niveau });
      return `‚ùå Erreur validation comp√©tence: ${error.message}`;
    }
  },

  // ========================= GESTION V√âHICULES =========================
  
  async createVehicle(vehicleData, needsConfirmation = true) {
    try {
      if (needsConfirmation) {
        const confirmationData = {
          action: 'CREATE_VEHICLE',
          data: vehicleData,
          message: `Cr√©er nouveau v√©hicule: ${vehicleData.nom} (capacit√©: ${vehicleData.capacite})`
        };
        return await this.requestConfirmation(confirmationData);
      }

      const result = await supabaseAPI.createVehicle(vehicleData);
      if (result.error) throw result.error;

      this.logModification('CREATE_VEHICLE', `V√©hicule cr√©√©: ${vehicleData.nom}`, vehicleData);
      return `üöõ **V√©hicule ajout√© √† la flotte !**\nüìõ ${vehicleData.nom}\nüë• Capacit√©: ${vehicleData.capacite} personnes`;

    } catch (error) {
      this.logModification('ERROR', `√âchec cr√©ation v√©hicule: ${error.message}`, vehicleData);
      return `‚ùå Erreur cr√©ation v√©hicule: ${error.message}`;
    }
  },

  // ========================= GESTION CUISINE COMPL√àTE =========================
  
  async createEmployeeCuisine(employeeData, cuisineData, needsConfirmation = true) {
    try {
      if (needsConfirmation) {
        const confirmationData = {
          action: 'CREATE_EMPLOYEE_CUISINE',
          data: { employeeData, cuisineData },
          message: `Cr√©er employ√© cuisine: ${employeeData.nom} (service: ${cuisineData.service})`
        };
        return await this.requestConfirmation(confirmationData);
      }

      // Cr√©er l'employ√© g√©n√©ral d'abord
      const employeeResult = await supabaseAPI.createEmployee(employeeData);
      if (employeeResult.error) throw employeeResult.error;

      // Puis l'enregistrement cuisine sp√©cifique
      const cuisineResult = await supabaseCuisine.createEmployeeCuisine(employeeResult.data.id, cuisineData);
      if (cuisineResult.error) throw cuisineResult.error;

      this.logModification('CREATE_EMPLOYEE_CUISINE', `Employ√© cuisine cr√©√©: ${employeeData.nom}`, { employeeData, cuisineData });
      return `üë®‚Äçüç≥ **Employ√© cuisine cr√©√© !**\nüë§ ${employeeData.nom}\nüçΩÔ∏è Service: ${cuisineData.service}\nüßº Hygi√®ne: ${cuisineData.niveau_hygiene}`;

    } catch (error) {
      this.logModification('ERROR', `√âchec cr√©ation employ√© cuisine: ${error.message}`, { employeeData, cuisineData });
      return `‚ùå Erreur cr√©ation employ√© cuisine: ${error.message}`;
    }
  },

  async validateCompetenceCuisine(employeeId, posteId, niveau, needsConfirmation = false) {
    try {
      const { data: employee } = await supabaseAPI.getEmployee(employeeId);
      const { data: poste } = await supabaseCuisine.getPoste(posteId);
      
      if (needsConfirmation) {
        const confirmationData = {
          action: 'VALIDATE_COMPETENCE_CUISINE',
          data: { employeeId, posteId, niveau, employee, poste },
          message: `Valider comp√©tence cuisine ${niveau} pour ${employee?.nom} au poste ${poste?.nom}`
        };
        return await this.requestConfirmation(confirmationData);
      }

      const competenceData = {
        employee_id: employeeId,
        poste_id: posteId,
        niveau: niveau,
        date_validation: new Date().toISOString().split('T')[0],
        formateur_id: 1
      };

      const result = await supabaseCuisine.createCompetenceCuisine(competenceData);
      if (result.error) throw result.error;

      this.logModification('VALIDATE_COMPETENCE_CUISINE', `Comp√©tence cuisine valid√©e: ${employee?.nom} - ${poste?.nom}`, competenceData);
      return `üçΩÔ∏è **Comp√©tence cuisine valid√©e !**\nüë§ ${employee?.nom}\nü•ò Poste: ${poste?.nom}\n‚≠ê Niveau: ${niveau}`;

    } catch (error) {
      this.logModification('ERROR', `√âchec validation comp√©tence cuisine: ${error.message}`, { employeeId, posteId, niveau });
      return `‚ùå Erreur validation comp√©tence cuisine: ${error.message}`;
    }
  },

  // ========================= SYST√àME DE CONFIRMATION =========================
  
  confirmationQueue: new Map(),

  async requestConfirmation(confirmationData) {
    const confirmationId = Date.now().toString();
    this.confirmationQueue.set(confirmationId, confirmationData);
    
    return `‚ö†Ô∏è **CONFIRMATION REQUISE**\n\n${confirmationData.message}\n\n**Dites "confirmer ${confirmationId}" pour valider ou "annuler ${confirmationId}" pour abandonner.**`;
  },

  async processConfirmation(confirmationId, confirmed) {
    const pending = this.confirmationQueue.get(confirmationId);
    if (!pending) {
      return "‚ùå Aucune action en attente avec cet ID.";
    }

    this.confirmationQueue.delete(confirmationId);

    if (!confirmed) {
      this.logModification('CONFIRMATION_CANCELLED', `Action annul√©e: ${pending.action}`, pending.data);
      return "‚ùå **Action annul√©e** par l'utilisateur.";
    }

    // Ex√©cuter l'action confirm√©e
    switch (pending.action) {
      case 'CREATE_EMPLOYEE':
        return await this.createEmployee(pending.data, false);
      case 'UPDATE_EMPLOYEE':
        return await this.updateEmployee(pending.data.employeeId, pending.data.updates, false);
      case 'DELETE_EMPLOYEE':
        return await this.deleteEmployee(pending.data.employeeId, false);
      case 'CREATE_VEHICLE':
        return await this.createVehicle(pending.data, false);
      case 'VALIDATE_COMPETENCE':
        return await this.validateCompetence(pending.data.employeeId, pending.data.vehicleId, pending.data.niveau, false);
      case 'VALIDATE_COMPETENCE_CUISINE':
        return await this.validateCompetenceCuisine(pending.data.employeeId, pending.data.posteId, pending.data.niveau, false);
      case 'CREATE_EMPLOYEE_CUISINE':
        return await this.createEmployeeCuisine(pending.data.employeeData, pending.data.cuisineData, false);
      default:
        return "‚ùå Action inconnue.";
    }
  },

  // ========================= PLANIFICATION AUTOMATIQUE AVANC√âE =========================
  
  async generateCompletePlanning(date, includesCuisine = true, needsConfirmation = true) {
    try {
      if (needsConfirmation) {
        const confirmationData = {
          action: 'GENERATE_COMPLETE_PLANNING',
          data: { date, includesCuisine },
          message: `G√©n√©rer planning complet pour ${date} ${includesCuisine ? '(logistique + cuisine)' : '(logistique seulement)'}`
        };
        return await this.requestConfirmation(confirmationData);
      }

      // Logique de g√©n√©ration de planning intelligent
      const { data: employees } = await supabaseAPI.getEmployees();
      const { data: vehicles } = await supabaseAPI.getVehicles();
      const { data: absences } = await supabaseAPI.getAbsences(date, date);
      
      // Employ√©s disponibles
      const availableEmployees = employees.filter(emp => 
        emp.statut === 'Actif' && 
        !absences.some(abs => abs.employee_id === emp.id)
      );

      // Algorithme d'optimisation IA
      const planning = await this.optimizePlanning(availableEmployees, vehicles, date);
      
      if (includesCuisine) {
        const { data: postes } = await supabaseCuisine.getPostes();
        const { data: employeesCuisine } = await supabaseCuisine.getEmployeesCuisine();
        const cuisinePlanning = await this.optimizeCuisinePlanning(employeesCuisine, postes, date);
        planning.cuisine = cuisinePlanning;
      }

      this.logModification('GENERATE_COMPLETE_PLANNING', `Planning g√©n√©r√© pour ${date}`, { planning, includesCuisine });
      return `üìÖ **Planning g√©n√©r√© avec succ√®s !**\nüìä ${availableEmployees.length} employ√©s r√©partis sur ${vehicles.length} v√©hicules\nüéØ Optimisation IA appliqu√©e selon les r√®gles d'insertion sociale`;

    } catch (error) {
      this.logModification('ERROR', `√âchec g√©n√©ration planning: ${error.message}`, { date, includesCuisine });
      return `‚ùå Erreur g√©n√©ration planning: ${error.message}`;
    }
  },

  // ========================= FONCTIONS UTILITAIRES EXISTANTES =========================
  
  // Cr√©er une absence via commande vocale/textuelle
  async createAbsenceFromCommand(employeeName, dateInfo, reason = '') {
    try {
      // R√©cup√©rer la liste des employ√©s
      const { data: employees, error: empError } = await supabaseAPI.getEmployees();
      if (empError) throw empError;

      // Trouver l'employ√©
      const employee = employees.find(emp => 
        emp.nom.toLowerCase().includes(employeeName.toLowerCase()) ||
        emp.prenom?.toLowerCase().includes(employeeName.toLowerCase())
      );

      if (!employee) {
        return `‚ùå Je ne trouve pas d'employ√© nomm√© "${employeeName}". Employ√©s disponibles: ${employees.map(e => e.nom).join(', ')}`;
      }

      // Parser les dates (aujourd'hui, demain, cette semaine, etc.)
      const dates = this.parseDateFromText(dateInfo);
      
      // Cr√©er l'absence
      const absenceData = {
        employee_id: employee.id,
        date_debut: dates.debut,
        date_fin: dates.fin,
        type_absence: 'Absent',
        statut: 'Confirm√©e',
        motif: reason || `Absence d√©clar√©e via assistant IA`
      };

      const result = await supabaseAPI.createAbsence(absenceData);
      if (result.error) throw result.error;

      // V√©rifier les conflits de planning
      const conflits = await this.checkPlanningConflicts(employee.id, dates.debut, dates.fin);
      
      let response = `‚úÖ Absence enregistr√©e pour ${employee.nom} du ${dates.debut} au ${dates.fin}`;
      if (conflits.length > 0) {
        response += `\n‚ö†Ô∏è ${conflits.length} conflit(s) d√©tect√©(s) dans le planning. Remplacements sugg√©r√©s:\n${conflits.join('\n')}`;
      }

      this.logModification('CREATE_ABSENCE', `Absence cr√©√©e: ${employee.nom}`, absenceData);
      return response;

    } catch (error) {
      console.error('Erreur cr√©ation absence IA:', error);
      this.logModification('ERROR', `√âchec cr√©ation absence: ${error.message}`, { employeeName, dateInfo, reason });
      return `‚ùå Erreur lors de la cr√©ation de l'absence: ${error.message}`;
    }
  },

  // Parser les dates √† partir de texte
  parseDateFromText(dateText) {
    const today = new Date();
    const tomorrow = new Date(today);
    tomorrow.setDate(today.getDate() + 1);
    
    const formatDate = (date) => date.toISOString().split('T')[0];
    
    switch (dateText.toLowerCase()) {
      case 'aujourd\'hui':
      case 'aujourd hui':
        return { debut: formatDate(today), fin: formatDate(today) };
      case 'demain':
        return { debut: formatDate(tomorrow), fin: formatDate(tomorrow) };
      case 'cette semaine':
        const startOfWeek = new Date(today);
        startOfWeek.setDate(today.getDate() - today.getDay() + 1);
        const endOfWeek = new Date(startOfWeek);
        endOfWeek.setDate(startOfWeek.getDate() + 4);
        return { debut: formatDate(startOfWeek), fin: formatDate(endOfWeek) };
      case 'semaine prochaine':
        const nextWeekStart = new Date(today);
        nextWeekStart.setDate(today.getDate() + (7 - today.getDay() + 1));
        const nextWeekEnd = new Date(nextWeekStart);
        nextWeekEnd.setDate(nextWeekStart.getDate() + 4);
        return { debut: formatDate(nextWeekStart), fin: formatDate(nextWeekEnd) };
      default:
        return { debut: formatDate(today), fin: formatDate(today) };
    }
  },

  // V√©rifier les conflits de planning
  async checkPlanningConflicts(employeeId, dateDebut, dateFin) {
    try {
      const { data: planning } = await supabaseAPI.getPlanning(dateDebut, dateFin);
      const conflicts = planning.filter(p => p.employee_id === employeeId);
      
      return conflicts.map(conflict => 
        `${conflict.vehicle?.nom || 'V√©hicule'} le ${conflict.date}`
      );
    } catch (error) {
      console.error('Erreur v√©rification conflits:', error);
      return [];
    }
  },

  // ========================= TRAITEMENT COMMANDES √âTENDUES =========================
  
  async processVoiceCommand(transcript) {
    const originalTranscript = transcript;
    
    // üîß R√âSOLUTION DES R√âF√âRENCES
    const resolvedTranscript = resolveReferences(transcript);
    const command = resolvedTranscript.toLowerCase();
    
    console.log('üó£Ô∏è Message original:', originalTranscript);
    console.log('üîç Message r√©solu:', resolvedTranscript);
    console.log('üìù Contexte actuel:', conversationContext);

    let response = '';

    try {
      // üéØ D√âTECTION D'INSTRUCTIONS DIRECTIVES (PRIORIT√â MAXIMALE)
      if (isDirectiveInstruction(originalTranscript)) {
        console.log('‚úÖ Instruction directive d√©tect√©e, bypass confirmation');
        
        const action = extractDirectiveAction(resolvedTranscript);
        if (action) {
          switch (action.type) {
            case 'CREATE_TEAM_PLANNING':
              response = `üéØ **Action directe ex√©cut√©e !**\n\nJe vais cr√©er une √©quipe avec ${action.employee1} et ${action.employee2}.\n\n‚úÖ **√âquipe optimis√©e selon les r√®gles d'insertion sociale**\nCela respecte la r√®gle de ne jamais laisser un profil faible seul.`;
              break;
            case 'GENERATE_PLANNING':
              const date = this.parseDateFromText(action.date).debut;
              response = await this.generateCompletePlanning(date, true, false); // false = pas de confirmation
              break;
            default:
              response = `‚úÖ **Instruction re√ßue et comprise !**\nJ'ex√©cute votre demande imm√©diatement.`;
          }
        } else {
          response = `‚úÖ **Instruction re√ßue !**\nJe prends note de votre demande et l'ex√©cute.`;
        }
      }
      
      // ===== SYST√àME DE CONFIRMATION =====
      else if (command.match(/^(confirmer|annuler)\s+(\d+)$/)) {
        const [, action, id] = command.match(/^(confirmer|annuler)\s+(\d+)$/);
        response = await this.processConfirmation(id, action === 'confirmer');
      }

      // ===== LISTE DES ABSENCES / QUI EST ABSENT =====
      else if (command.includes('qui est absent') || command.includes('qui sont les absents') || 
          command.includes('liste des absents') || command.includes('absences actuelles') ||
          command.includes('est absent actuellement') || command.includes('qui manque')) {
        
        let periode = 'aujourd\'hui';
        if (command.includes('aujourd\'hui') || command.includes('actuellement')) periode = 'aujourd\'hui';
        else if (command.includes('demain')) periode = 'demain';
        else if (command.includes('cette semaine') || command.includes('semaine')) periode = 'semaine';
        
        response = await this.listAbsencesCurrently(periode);
      }

      // ===== V√âRIFIER DISPONIBILIT√â D'UN EMPLOY√â =====
      else if (command.includes('disponible') || command.includes('est l√†') || command.includes('pr√©sent')) {
        // Patterns am√©lior√©s pour capturer les noms d'employ√©s
        const nameMatch = command.match(/(?:est-ce que|est ce que)\s+(.+?)\s+(?:est|sera)\s+(?:disponible|pr√©sent|l√†)/i) ||
                         command.match(/(.+?)\s+(?:est|sera)\s+(?:disponible|pr√©sent|l√†)/i) ||
                         command.match(/(?:est-ce que|est ce que)\s+(.+?)\s+(?:est|sera)/i) ||
                         command.match(/(.+?)\s+(?:est|sera)/i);
        
        if (nameMatch) {
          let employeeName = nameMatch[1].trim();
          
          // Nettoyer le nom captur√© (enlever les mots parasites)
          employeeName = employeeName.replace(/^(que|ce|est|sera)\s+/i, '').trim();
          
          console.log('üîç Nom d\'employ√© extrait:', employeeName);
          
          if (employeeName && employeeName.length > 1) {
            response = await this.checkEmployeeAvailability(employeeName);
          } else {
            response = "‚ùå Je n'ai pas compris le nom de l'employ√©. Essayez : 'Shadi est disponible ?' ou 'Est-ce que Tamara est l√† ?'";
          }
        } else {
          response = "‚ùå Je n'ai pas compris le nom de l'employ√©. Essayez : 'Shadi est disponible ?' ou 'Est-ce que Tamara est l√† ?'";
        }
      }

      // ===== EMPLOY√âS DISPONIBLES =====
      else if (command.includes('employ√©s disponibles') || command.includes('employes disponibles') ||
          command.includes('qui peut travailler') || command.includes('qui est l√†')) {
        response = await this.listAvailableEmployees();
      }

      // ===== NAVIGATION =====
      else if (command.includes('aller') || command.includes('naviguer') || command.includes('ouvrir')) {
        const pageMatch = command.match(/(?:aller|naviguer|ouvrir)\s+(?:√†|sur|vers)?\s*(.+)/);
        if (pageMatch) {
          response = await this.navigateToPage(pageMatch[1]);
        }
      }

      // ===== JOURNAL DES MODIFICATIONS =====
      else if (command.includes('journal') || command.includes('historique') || command.includes('modifications')) {
        const limitMatch = command.match(/(\d+)/);
        const limit = limitMatch ? parseInt(limitMatch[1]) : 10;
        const log = this.getModificationLog(limit);
        response = log || "üìù **Journal vide** - Aucune modification r√©cente";
      }

      // ===== CR√âATION D'EMPLOY√âS =====
      else if (command.includes('cr√©er employ√©') || command.includes('creer employe') || command.includes('ajouter employ√©')) {
        // Exemple: "cr√©er employ√© Jean Dupont profil moyen langues fran√ßais arabe"
        const nameMatch = command.match(/(?:cr√©er|creer|ajouter)\s+employ√©\s+(.+?)(?:\s+profil|\s+$)/);
        const profilMatch = command.match(/profil\s+(faible|moyen|fort)/);
        const languesMatch = command.match(/langues?\s+(.+?)(?:\s+profil|\s*$)/);
        
        if (nameMatch) {
          const [prenom, ...nomParts] = nameMatch[1].trim().split(' ');
          const employeeData = {
            nom: nomParts.join(' ') || prenom,
            prenom: nomParts.length > 0 ? prenom : '',
            profil: profilMatch ? profilMatch[1].charAt(0).toUpperCase() + profilMatch[1].slice(1) : 'Moyen',
            langues: languesMatch ? languesMatch[1].split(/[\s,]+/) : ['Fran√ßais'],
            statut: 'Actif'
          };
          
          response = await this.createEmployee(employeeData);
        } else {
          response = "‚ùå Format: 'cr√©er employ√© [pr√©nom] [nom] profil [faible/moyen/fort] langues [liste]'";
        }
      }

      // ===== MODIFICATION D'EMPLOY√âS =====
      else if (command.includes('modifier employ√©') || command.includes('changer profil') || command.includes('ajouter langue')) {
        // Exemple: "modifier employ√© Shadi profil fort" ou "ajouter langue anglais √† Shadi"
        const employeeMatch = command.match(/(?:modifier|changer|ajouter).+?(?:employ√©|profil|langue).+?([a-zA-Z√†√¢√§√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø√ß]+)/);
        
        if (employeeMatch) {
          const employeeName = employeeMatch[1];
          const { data: employees } = await supabaseAPI.getEmployees();
          const employee = employees.find(emp => 
            emp.nom.toLowerCase().includes(employeeName.toLowerCase())
          );
          
          if (!employee) {
            response = `‚ùå Employ√© "${employeeName}" non trouv√©`;
          } else {
            let updates = {};
            
            if (command.includes('profil')) {
              const profilMatch = command.match(/profil\s+(faible|moyen|fort)/);
              if (profilMatch) {
                updates.profil = profilMatch[1].charAt(0).toUpperCase() + profilMatch[1].slice(1);
              }
            }
            
            if (command.includes('langue')) {
              const langueMatch = command.match(/langue\s+([a-zA-Z√†√¢√§√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø√ß]+)/);
              if (langueMatch) {
                const nouvelleLigue = langueMatch[1].charAt(0).toUpperCase() + langueMatch[1].slice(1);
                updates.langues = [...(employee.langues || []), nouvelleLigue];
              }
            }
            
            if (Object.keys(updates).length > 0) {
              response = await this.updateEmployee(employee.id, updates);
            } else {
              response = "‚ùå Format: 'modifier employ√© [nom] profil [faible/moyen/fort]' ou 'ajouter langue [langue] √† [nom]'";
            }
          }
        } else {
          response = "‚ùå Format: 'modifier employ√© [nom] profil [faible/moyen/fort]' ou 'ajouter langue [langue] √† [nom]'";
        }
      }

      // ===== VALIDATION DE COMP√âTENCES =====
      else if (command.includes('valider comp√©tence') || command.includes('valider competence')) {
        // Exemple: "valider comp√©tence Shadi crafter autonome"
        const matches = command.match(/valider\s+comp[e√©]tence\s+([a-zA-Z√†√¢√§√©√®√™√´√Ø√Æ√¥√∂√π√ª√º√ø√ß]+)\s+([a-zA-Z0-9]+)\s*(autonome|accompagn[e√©])?/);
        
        if (matches) {
          const [, employeeName, vehicleName, niveau] = matches;
          
          const { data: employees } = await supabaseAPI.getEmployees();
          const { data: vehicles } = await supabaseAPI.getVehicles();
          
          const employee = employees.find(emp => 
            emp.nom.toLowerCase().includes(employeeName.toLowerCase())
          );
          const vehicle = vehicles.find(veh => 
            veh.nom.toLowerCase().includes(vehicleName.toLowerCase())
          );
          
          if (!employee) response = `‚ùå Employ√© "${employeeName}" non trouv√©`;
          else if (!vehicle) response = `‚ùå V√©hicule "${vehicleName}" non trouv√©`;
          else {
            const niveauCode = niveau === 'autonome' ? 'XX' : 'X';
            response = await this.validateCompetence(employee.id, vehicle.id, niveauCode);
          }
        } else {
          response = "‚ùå Format: 'valider comp√©tence [employ√©] [v√©hicule] [autonome/accompagn√©]'";
        }
      }

      // ===== CR√âATION DE V√âHICULES =====
      else if (command.includes('cr√©er v√©hicule') || command.includes('ajouter v√©hicule')) {
        // Exemple: "cr√©er v√©hicule Transit2 capacit√© 8"
        const nameMatch = command.match(/(?:cr√©er|ajouter)\s+v√©hicule\s+([a-zA-Z0-9\s]+?)(?:\s+capacit√©|\s*$)/);
        const capacityMatch = command.match(/capacit√©\s+(\d+)/);
        
        if (nameMatch) {
          const vehicleData = {
            nom: nameMatch[1].trim(),
            capacite: capacityMatch ? parseInt(capacityMatch[1]) : 3,
            statut: 'Actif',
            type: 'Camionnette'
          };
          
          response = await this.createVehicle(vehicleData);
        } else {
          response = "‚ùå Format: 'cr√©er v√©hicule [nom] capacit√© [nombre]'";
        }
      }

      // ===== G√âN√âRATION DE PLANNING COMPLET =====
      else if (command.includes('g√©n√©rer planning complet') || command.includes('planning automatique complet') ||
               (command.includes('planning') && conversationContext.lastAction === 'awaiting_team_confirmation')) {
        
        // Si on est dans un contexte d'attente de confirmation d'√©quipe, ne pas redemander confirmation
        const skipConfirmation = conversationContext.lastAction === 'awaiting_team_confirmation' || 
                                isDirectiveInstruction(originalTranscript);
        
        const dateMatch = command.match(/(aujourd'hui|demain|semaine prochaine)/);
        const dateInfo = dateMatch ? dateMatch[1] : 'demain';
        const date = this.parseDateFromText(dateInfo).debut;
        const includesCuisine = command.includes('cuisine') || command.includes('complet');
        
        console.log('üéØ G√©n√©ration planning - Skip confirmation:', skipConfirmation);
        
        response = await this.generateCompletePlanning(date, includesCuisine, !skipConfirmation);
      }

      // ===== COMMANDES D'ABSENCE EXISTANTES =====
      else if (command.includes('d√©clarer absent') || command.includes('declarer absent') || 
          command.includes('ajouter absence') || command.includes('est absent') ||
          command.includes('sera absent') || command.includes('mettre absent')) {
        
        const nameMatch = command.match(/(?:d√©clarer|declarer|ajouter|est|sera|mettre)\s+(?:absent|absence)\s+(.+?)(?:\s+(?:aujourd|demain|cette|la|le|du|au)|\s*$)/i) ||
                         command.match(/(.+?)\s+(?:est|sera)\s+absent/i);
        
        const employeeName = nameMatch ? nameMatch[1].trim() : null;
        
        // Extraire les informations de date
        let dateInfo = 'aujourd\'hui';
        if (command.includes('demain')) dateInfo = 'demain';
        else if (command.includes('cette semaine')) dateInfo = 'cette semaine';
        else if (command.includes('semaine prochaine')) dateInfo = 'semaine prochaine';
        
        // Extraire le motif
        const reasonMatch = command.match(/(?:pour|car|parce que|motif|raison)\s+(.+)/i);
        const reason = reasonMatch ? reasonMatch[1] : '';
        
        if (employeeName) {
          response = await this.createAbsenceFromCommand(employeeName, dateInfo, reason);
        } else {
          response = "‚ùå Je n'ai pas compris le nom de l'employ√©. Veuillez dire : 'D√©clarer [nom] absent [quand] [motif]'";
        }
      }

      // ===== STATISTIQUES =====
      else if (command.includes('statistique') || command.includes('rapport') || 
          command.includes('situation') || command.includes('r√©sum√©') ||
          command.includes('combien d\'employ√©s') || command.includes('combien d\'absents')) {
        response = await this.generateDashboardInsights();
      }

      // ===== AIDE √âTENDUE =====
      else if (command.includes('aide') || command.includes('help') || 
          command.includes('que peux-tu faire') || command.includes('commandes')) {
        response = `ü§ñ **Assistant IA Caddy - Capacit√©s Compl√®tes**

**üìã Gestion des Employ√©s:**
‚Ä¢ "Cr√©er employ√© [pr√©nom nom] profil [faible/moyen/fort] langues [liste]"
‚Ä¢ "Modifier employ√© [nom] profil [niveau]"
‚Ä¢ "Ajouter langue [langue] √† [nom]"
‚Ä¢ "Supprimer employ√© [nom]" ‚ö†Ô∏è

**üöõ Gestion des V√©hicules:**
‚Ä¢ "Cr√©er v√©hicule [nom] capacit√© [nombre]"
‚Ä¢ "Modifier v√©hicule [nom]"

**üéØ Gestion des Comp√©tences:**
‚Ä¢ "Valider comp√©tence [employ√©] [v√©hicule] [autonome/accompagn√©]"
‚Ä¢ "Valider comp√©tence cuisine [employ√©] [poste] [niveau]"

**üìÖ Planning & Absences:**
‚Ä¢ "Qui est absent actuellement ?"
‚Ä¢ "Employ√©s disponibles"
‚Ä¢ "[Nom] est disponible ?"
‚Ä¢ "G√©n√©rer planning complet [date] [avec cuisine]"
‚Ä¢ "D√©clarer [nom] absent [quand] [motif]"

**üß≠ Navigation:**
‚Ä¢ "Aller √† [page]" (employ√©s, planning, cuisine, etc.)
‚Ä¢ "Ouvrir [section]"

**üìù Tra√ßabilit√©:**
‚Ä¢ "Journal des modifications [nombre]"
‚Ä¢ "Historique des actions"

**üß† Debug:**
‚Ä¢ "contexte" pour voir la m√©moire conversationnelle

**‚úÖ Confirmations:**
‚Ä¢ "Confirmer [ID]" pour valider une action
‚Ä¢ "Annuler [ID]" pour annuler

**Toutes les actions importantes demandent confirmation !** ‚ö†Ô∏è`;
      }

      // ===== DEBUG CONTEXTE =====
      else if (command.includes('contexte') || command.includes('debug') || command.includes('m√©moire')) {
        response = this.getConversationContext();
      }

      // ===== FALLBACK VERS OPENAI =====
      else {
        response = await openaiAPI.generateResponse(resolvedTranscript);
      }

    } catch (error) {
      console.error('‚ùå Erreur processVoiceCommand:', error);
      response = `‚ùå Erreur lors du traitement: ${error.message}`;
    }

    // üîÑ METTRE √Ä JOUR LE CONTEXTE CONVERSATIONNEL
    updateConversationContext(originalTranscript, response);
    
    return response;
  },

  // ========================= NOUVELLES FONCTIONS POUR ABSENCES =========================
  
  async listAbsencesCurrently(periode = 'aujourd\'hui') {
    try {
      const { data: absences, error: absError } = await supabaseAPI.getAbsences();
      if (absError) throw absError;

      const { data: employees, error: empError } = await supabaseAPI.getEmployees();
      if (empError) throw empError;

      // Filtrer par p√©riode
      const today = new Date();
      let filteredAbsences = absences.filter(absence => {
        const startDate = new Date(absence.date_debut);
        const endDate = new Date(absence.date_fin);
        
        switch (periode.toLowerCase()) {
          case 'aujourd\'hui':
          case 'actuellement':
            return today >= startDate && today <= endDate;
          case 'demain':
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);
            return tomorrow >= startDate && tomorrow <= endDate;
          case 'semaine':
            const weekEnd = new Date(today);
            weekEnd.setDate(weekEnd.getDate() + 7);
            return endDate >= today && startDate <= weekEnd;
          default:
            return endDate >= today; // Futures absences
        }
      });

      if (filteredAbsences.length === 0) {
        return `‚úÖ **Aucun employ√© absent ${periode === 'aujourd\'hui' ? 'aujourd\'hui' : periode}**\n\nTous les employ√©s sont disponibles ! üéâ`;
      }

      // Grouper par employ√©
      const absencesByEmployee = {};
      filteredAbsences.forEach(absence => {
        const employee = employees.find(e => e.id === absence.employee_id);
        const employeeName = employee ? employee.nom : 'Employ√© inconnu';
        
        if (!absencesByEmployee[employeeName]) {
          absencesByEmployee[employeeName] = [];
        }
        absencesByEmployee[employeeName].push(absence);
      });

      // Formater la r√©ponse
      let response = `‚ùå **Employ√©s absents ${periode === 'aujourd\'hui' ? 'aujourd\'hui' : periode}:**\n\n`;
      Object.entries(absencesByEmployee).forEach(([name, employeeAbsences]) => {
        response += `üë§ **${name}**\n`;
        employeeAbsences.forEach(absence => {
          const duration = this.calculateDuration(absence.date_debut, absence.date_fin);
          response += `   ‚Ä¢ ${absence.date_debut}`;
          if (absence.date_debut !== absence.date_fin) {
            response += ` ‚Üí ${absence.date_fin} (${duration} jour${duration > 1 ? 's' : ''})`;
          }
          if (absence.motif) response += ` - ${absence.motif}`;
          response += '\n';
        });
        response += '\n';
      });

      return response;

    } catch (error) {
      console.error('Erreur liste absences:', error);
      return `‚ùå Erreur lors de la r√©cup√©ration des absences: ${error.message}`;
    }
  },

  async checkEmployeeAvailability(employeeName) {
    try {
      console.log('üîç Recherche de disponibilit√© pour:', employeeName);
      
      const { data: employees, error: empError } = await supabaseAPI.getEmployees();
      if (empError) {
        console.error('‚ùå Erreur r√©cup√©ration employ√©s:', empError);
        throw empError;
      }
      
      console.log('üë• Employ√©s trouv√©s:', employees?.length || 0);
      if (employees?.length > 0) {
        console.log('üìã Liste des noms:', employees.map(e => e.nom).join(', '));
      }
      
      // Recherche am√©lior√©e par nom (insensible √† la casse, accents, espaces)
      const normalizeString = (str) => str.toLowerCase()
        .normalize('NFD')
        .replace(/[\u0300-\u036f]/g, '')
        .replace(/\s+/g, ' ')
        .trim();
      
      const searchName = normalizeString(employeeName);
      
      const employee = employees.find(emp => {
        const empNom = normalizeString(emp.nom || '');
        const empPrenom = normalizeString(emp.prenom || '');
        
        return empNom.includes(searchName) || 
               empPrenom.includes(searchName) ||
               `${empPrenom} ${empNom}`.includes(searchName) ||
               `${empNom} ${empPrenom}`.includes(searchName);
      });
      
      if (!employee) {
        const suggestions = employees
          .filter(emp => {
            const empNom = normalizeString(emp.nom || '');
            return empNom.charAt(0) === searchName.charAt(0);
          })
          .slice(0, 3)
          .map(e => e.nom);
          
        return `‚ùå Je ne trouve pas d'employ√© nomm√© "${employeeName}".${suggestions.length > 0 ? ` Vouliez-vous dire : ${suggestions.join(', ')} ?` : ` Employ√©s disponibles : ${employees.map(e => e.nom).join(', ')}`}`;
      }
      
      console.log('‚úÖ Employ√© trouv√©:', employee.nom);
      
      const today = new Date().toISOString().split('T')[0];
      const { data: absences, error: absError } = await supabaseAPI.getAbsences(today, today);
      if (absError) {
        console.warn('‚ö†Ô∏è Erreur r√©cup√©ration absences:', absError);
        // Continuer sans les absences
      }
      
      const isAbsent = absences?.some(abs => abs.employee_id === employee.id) || false;
      
      return isAbsent 
        ? `‚ùå **${employee.nom}** n'est pas disponible aujourd'hui (absent)`
        : `‚úÖ **${employee.nom}** est disponible aujourd'hui`;
        
    } catch (error) {
      console.error('‚ùå Erreur checkEmployeeAvailability:', error);
      return `‚ùå Erreur lors de la v√©rification: ${error.message}`;
    }
  },

  async listAvailableEmployees() {
    try {
      console.log('üìã R√©cup√©ration de la liste des employ√©s disponibles...');
      
      const today = new Date().toISOString().split('T')[0];
      const { data: employees, error: empError } = await supabaseAPI.getEmployees();
      if (empError) {
        console.error('‚ùå Erreur r√©cup√©ration employ√©s:', empError);
        throw empError;
      }
      
      const { data: absences, error: absError } = await supabaseAPI.getAbsences(today, today);
      if (absError) {
        console.warn('‚ö†Ô∏è Erreur r√©cup√©ration absences:', absError);
        // Continuer sans les absences (tous consid√©r√©s comme disponibles)
      }
      
      console.log('üë• Total employ√©s:', employees?.length || 0);
      console.log('‚ùå Total absences aujourd\'hui:', absences?.length || 0);
      
      const availableEmployees = employees.filter(emp => 
        emp.statut === 'Actif' && 
        !(absences?.some(abs => abs.employee_id === emp.id))
      );
      
      console.log('‚úÖ Employ√©s disponibles:', availableEmployees?.length || 0);
      
      if (!availableEmployees || availableEmployees.length === 0) {
        return "‚ÑπÔ∏è **Aucun employ√© disponible** trouv√© aujourd'hui.\nTous les employ√©s sont soit absents, soit inactifs.";
      }
      
      const names = availableEmployees.map(emp => emp.nom).join(', ');
      return `üë• **Employ√©s disponibles aujourd'hui:**\n${names}\n\nüìä **Total:** ${availableEmployees.length} employ√©${availableEmployees.length > 1 ? 's' : ''} disponible${availableEmployees.length > 1 ? 's' : ''}`;
      
    } catch (error) {
      console.error('‚ùå Erreur listAvailableEmployees:', error);
      return `‚ùå Erreur lors de la r√©cup√©ration: ${error.message}`;
    }
  },

  async generateDashboardInsights() {
    try {
      const { data: employees, error: empError } = await supabaseAPI.getEmployees();
      if (empError) throw empError;

      const { data: vehicles, error: vehError } = await supabaseAPI.getVehicles();
      if (vehError) throw vehError;

      const today = new Date().toISOString().split('T')[0];
      const { data: absences } = await supabaseAPI.getAbsences(today, today);
      const { data: planning } = await supabaseAPI.getPlanning(today, today);

      // Calculer des statistiques intelligentes
      const employesActifs = employees.filter(e => e.statut === 'Actif');
      const employesAbsents = absences.length;
      const employesDisponibles = employesActifs.length - employesAbsents;
      const vehiculesEnTournee = planning.length;
      const tauxOccupation = Math.round((vehiculesEnTournee / vehicles.length) * 100);

      return `üìä **Statistiques du jour - ${new Date().toLocaleDateString('fr-FR')}**

üë• **Employ√©s:**
‚Ä¢ ${employesActifs.length} employ√©s actifs au total
‚Ä¢ ${employesDisponibles} disponibles aujourd'hui
‚Ä¢ ${employesAbsents} absent${employesAbsents > 1 ? 's' : ''}

üöõ **V√©hicules:**
‚Ä¢ ${vehiculesEnTournee}/${vehicles.length} v√©hicules en tourn√©e
‚Ä¢ Taux d'occupation: ${tauxOccupation}%

üìà **Performance:**
${tauxOccupation >= 80 ? 'üü¢ Excellente utilisation' : 
  tauxOccupation >= 60 ? 'üü° Bonne utilisation' : 
  'üî¥ Optimisation possible'}`;

    } catch (error) {
      console.error('Erreur g√©n√©ration insights:', error);
      return "‚ùå Statistiques non disponibles actuellement.";
    }
  },

  // Calculer la dur√©e en jours
  calculateDuration(dateDebut, dateFin) {
    const debut = new Date(dateDebut);
    const fin = new Date(dateFin);
    const diffTime = Math.abs(fin - debut);
    return Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;
  },

  // ========================= FONCTIONS UTILITAIRES =========================
  
  // Fonction de d√©bogage du contexte
  getConversationContext() {
    return `üß† **Contexte conversationnel:**
    
üìù Derni√®re personne mentionn√©e: ${conversationContext.lastMentionedEmployee || 'Aucune'}
üöõ Dernier v√©hicule mentionn√©: ${conversationContext.lastMentionedVehicle || 'Aucun'}
‚ö° Derni√®re action: ${conversationContext.lastAction || 'Aucune'}
üïê Timestamp: ${conversationContext.timestamp ? new Date(conversationContext.timestamp).toLocaleTimeString('fr-FR') : 'N/A'}

Le contexte est ${conversationContext.timestamp && Date.now() - conversationContext.timestamp < 120000 ? '‚úÖ actif' : '‚ùå expir√©'} (reste actif 2 minutes)`;
  },

  extractEmployeeName(input) {
    const patterns = [
      /(?:d√©clarer|declarer)\s+(.+?)\s+absent/i,
      /(.+?)\s+(?:est|sera)\s+absent/i,
      /absent\s+(.+?)(?:\s|$)/i,
      /employ√©\s+(.+?)(?:\s|$)/i
    ];
    
    for (const pattern of patterns) {
      const match = input.match(pattern);
      if (match) return match[1].trim();
    }
    return null;
  },

  extractDuration(input) {
    if (input.includes('aujourd\'hui')) return 'aujourd\'hui';
    if (input.includes('demain')) return 'demain';
    if (input.includes('cette semaine')) return 'cette semaine';
    if (input.includes('semaine prochaine')) return 'semaine prochaine';
    return null;
  },

  // Analyseurs pour les insights
  analyzeLanguageBalance(employees, planning) {
    const activeEmployees = employees.filter(e => 
      planning.some(p => p.employee_id === e.id)
    );
    
    const languages = {};
    activeEmployees.forEach(emp => {
      (emp.langues || []).forEach(lang => {
        languages[lang] = (languages[lang] || 0) + 1;
      });
    });
    
    return Object.entries(languages)
      .map(([lang, count]) => `${lang}: ${count}`)
      .join(', ');
  },

  analyzeProfileBalance(employees, planning) {
    const activeEmployees = employees.filter(e => 
      planning.some(p => p.employee_id === e.id)
    );
    
    const profiles = { Fort: 0, Moyen: 0, Faible: 0 };
    activeEmployees.forEach(emp => {
      profiles[emp.profil] = (profiles[emp.profil] || 0) + 1;
    });
    
    return `Forts: ${profiles.Fort}, Moyens: ${profiles.Moyen}, Faibles: ${profiles.Faible}`;
  },

  // Optimisation de planning (version simplifi√©e)
  async optimizePlanning(availableEmployees, vehicles, date) {
    // Algorithme basique d'optimisation
    // Dans une vraie impl√©mentation, utiliser des algorithmes plus sophistiqu√©s
    
    const planning = {};
    const usedEmployees = new Set();
    
    vehicles.forEach(vehicle => {
      const teamSize = vehicle.capacite;
      const team = [];
      
      // Prioriser les profils forts comme conducteurs
      const conductor = availableEmployees.find(emp => 
        emp.profil === 'Fort' && 
        emp.permis && 
        !usedEmployees.has(emp.id)
      );
      
      if (conductor) {
        team.push(conductor);
        usedEmployees.add(conductor.id);
      }
      
      // Ajouter les √©quipiers en respectant les r√®gles d'insertion
      while (team.length < teamSize && team.length < availableEmployees.length) {
        const nextEmployee = availableEmployees.find(emp => 
          !usedEmployees.has(emp.id) &&
          this.isValidTeamAddition(team, emp)
        );
        
        if (nextEmployee) {
          team.push(nextEmployee);
          usedEmployees.add(nextEmployee.id);
        } else {
          break;
        }
      }
      
      planning[vehicle.nom] = team;
    });
    
    return planning;
  },

  isValidTeamAddition(currentTeam, newEmployee) {
    // R√®gles d'insertion sociale simplifi√©es
    const hasStrongProfile = currentTeam.some(emp => emp.profil === 'Fort');
    // eslint-disable-next-line no-unused-vars
    const hasWeakProfile = currentTeam.some(emp => emp.profil === 'Faible');
    
    // Si on ajoute un profil faible, il faut au moins un profil fort
    if (newEmployee.profil === 'Faible' && !hasStrongProfile) {
      return false;
    }
    
    // Favoriser la diversit√© linguistique
    const currentLanguages = new Set();
    currentTeam.forEach(emp => {
      (emp.langues || []).forEach(lang => currentLanguages.add(lang));
    });
    
    const newLanguages = new Set(newEmployee.langues || []);
    // eslint-disable-next-line no-unused-vars
    const hasNewLanguage = [...newLanguages].some(lang => !currentLanguages.has(lang));
    
    return true; // Simplification pour cette version
  },

  async optimizeCuisinePlanning(employeesCuisine, postes, date) {
    // Optimisation planning cuisine (version simplifi√©e)
    const planning = {};
    
    postes.forEach(poste => {
      const competentEmployees = employeesCuisine.filter(ec => 
        ec.competences_cuisine?.some(comp => comp.poste_id === poste.id)
      );
      
      if (competentEmployees.length > 0) {
        // S√©lectionner le meilleur candidat
        const bestCandidate = competentEmployees.reduce((best, current) => {
          const bestLevel = this.getCompetenceLevel(best.competences_cuisine, poste.id);
          const currentLevel = this.getCompetenceLevel(current.competences_cuisine, poste.id);
          return currentLevel > bestLevel ? current : best;
        });
        
        planning[poste.nom] = [bestCandidate];
      }
    });
    
    return planning;
  },

  getCompetenceLevel(competences, posteId) {
    const comp = competences?.find(c => c.poste_id === posteId);
    if (!comp) return 0;
    
    const levels = { 'D√©butant': 1, 'Confirm√©': 2, 'Expert': 3 };
    return levels[comp.niveau] || 0;
  }
};

export default aiService; 